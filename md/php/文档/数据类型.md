# 数据类型

## 空值
* 字面值：`null`,`NULL`
* 强制转换为空值：`(unset)$var`

## 布尔型
* 关键字：`bool`,`boolean`
* 字面值：`true`,`false`
* 强制转换到布尔型：`(关键字)$var`,`boolval($var)`
    * 以下值转换为`bool`时结果为`false`,其余未列出的情况转换结果为`true`
        * 布尔型:false
        * 整型值:0
        * 浮点型值:0.0
        * 字符串:"0",""
        * 空数组:array()
        * 空型值:null
        * 从空标记生成的`SimpleXML`对象 
* 自动转换为布尔型:当运算符,函数,流程控制需要一个布尔型值时,它会自动转换为布尔值

## 整型
* 关键字：`int`,`integer`
* 字面值
    * 数制:详见`regex.md`中的`常用匹配->整数`
    * `-`前缀:负数
    * 无前缀或`+`前缀:正数
    * 含`e`或`E`:科学计数法,表示以10为底的幂.`5e2`表示:5乘以(10的2次方) 
    * 示例：`0b1000`,`010`,`8`,`0x8`,`2e2`,`-200`,`+200`,`200`,
* 最值
    * `PHP_INT_MIN`：最小值
    * `PHP_INT_MAX`：最大值
* 强制转换到整型:`(关键字)$var`,`intval($var)`
    * 布尔型:false:0,true:1
    * 整型:未变化
    * 浮点型:
        * 正常浮点值且整数部分在整型的取值范围内:向下取整
        * 正常浮点值且整数部分超出整型的取值范围:未定义
        * `NAN`:0
        * `INF`:0
        * 警告:不要将一个运算结果为浮点的表达式或存储浮点运算结果的变量转换为整型,由于浮点数在计算机内部表示不精确,结果可能出乎意料
    * 字符串:如果字符串以合法的数值开始,则将其转换为浮点,再由浮点转换为整数
    * 其他类型转换到整型:未定义,勿使用 
* 自动转换为整型:当运算符,函数或流程控制需要一个数值时,如果字符串以合法的数值开始且这个数值中不包含`e`,`E`,`.`且这个数值在整型的范围之内,则转换为整数
* 精确计算:插件`php-gmp`或`php-bcmath`

## 浮点型
* 关键字：`float`,`double`,`real`
* 字面值
    * 详见`regex.md`中的`常用匹配->浮点数`
    * `NAN`：非数字
    * `INF`：无穷大
    * 含`e`或`E`:科学计数法,表示以10为底的幂.`5.1e2`表示:5.1乘以(10的2次方) 
    * 示例：`22323232323232323323`,`2.5`,`2.5e3`,`NAN`,`INF`
* 强制转换为浮点:`(关键字)$var`,`floatval($var)`
    * 布尔型:false:0,true:1
    * 整型:值未变化,类型转换为浮点型
    * 浮点:未变化
    * 字符串:如果字符串以合法的数值开始,则将其转换为这个数值.如果这个字符串不以数值开头,则转换为0 
    * 其他类型转换到浮点:未定义,勿使用 
* 自动转换为浮点:当运算符,函数或流程控制需要一个数值时,如果字符串以合法的数值开始,并且这个数值包含`.`,`e`或`E`或这个数值不在整型的范围之内,则转换为浮点型
* 精确计算:插件`php-bcmath`
* 浮点比较
    * 浮点不能比较相等,可以使用以下方式比较
        ```php
        $a = 1.23456789;
        $b = 1.23456780;
        //可以接受的精度误差
        $epsilon = 0.00001;             
        if(abs($a-$b) < $epsilon) {
            echo "true";
        }
        ```

## 字符串型
* 关键字:`string`
* 书写方式
    * 单引号包裹:只需要转义`'`和`\`,其他字符原样显示
        * 示例：`'abc'`,`'a\\b\'c\''`
    * 双引号:需要转义的字符如下
        * 变量解析:对已经定义的变量(整形,浮点型,字符串型)可直接在字符串中解析如"ab$var",如果直接解析会产生歧义,则将变量使用`{}`包裹,如`ab{$var}v`。如果使用`{}`包裹后会对实际需要使用`{}`符号的位置产生歧义，则应在外层再加一层`{}`,如`{{$str}}`
        * 转义
            * `\n`:换行,`ASCII`为`0x0A`
            * `\r`:回车,`ASCII`为`0x0D`
            * `\t`:水平制表符,`ASCII`为`0x09`
            * `\v`:垂直制表符,`ASCII`为`0x0B`
            * `\e`:取消符,`ASCII`为`0x1B`
            * `\f`:换页符,`ASCII`为`0x0C`
            * `\\`:反斜线,`ASCII`为`0x0D`
            * `\$`:美元符,`ASCII`为`0x0D`
            * `\"`:双引号,`ASCII`为`0x0D`
            * `\[0-7]{1,3}`:符合该正则表达式序列的是一个以八进制方式来表达的字符
            * `\x[0-9A-Fa-f]{1,2}`:符合该正则表达式序列的是一个以十六进制方式来表达的字符
        * 示例：`"abc"`,`"a\\b\"c\"\nd"`
    * Heredoc结构
        * 语法
            1. 被赋值的变量首行应为`$var=<<<HDOC`形式,其中`HDOC`为起始标识,可自定义(只能包含字母、数字和下划线，并且必须以字母和下划线作为开头)
            1. 然后换行,从第二行开始,可以书写任意字符串,其中在此结构内无需转义`"`和`\`,其余的转义规则、解析规则与双引号相同
            1. 最后一行为结束标识形式应为`HDOC;`,此行必须顶格且`;`后不能有任何字符(包括空格)
        * 示例 
            ```php
            $str=<<<EOD
            Example of string
            spanning multiple lines
            using heredoc syntax.
            EOD;
            ```
    * Nowdoc结构
        * 语法
            1. 被赋值的变量首行应为`$var=<<<'NDOC'`形式,其中`NDOC`为起始标识,可自定义(只能包含字母、数字和下划线，并且必须以字母和下划线作为开头)
            1. 然后换行,从第二行开始,可以书写任意字符串,不进行任何转义和解析
            1. 最后一行为结束标识形式应为`NDOC;`,此行必须顶格且`;`后不能有任何字符(包括空格)
        * 示例 
            ```php
            $str=<<<'EOD'
            'Example' of string
            spanning multiple lines
            using heredoc syntax.
            EOD;
            ```
* 访问和修改单字节字符,可以使用下标`[2]或{2}`访问和修改.超出数组长度的下标会加长字符串的长度,并将多余的长度使用空格填充.示例:
    ```php
    $a="abc";
    $a[1]=5;
    echo $a;
    ```
* 强制转换到字符串型:`(关键字)$var`,`strval($val)`
    * null:""
    * 布尔型:false:"",true:"1"
    * 整型:转换为数字的字面样式
    * 浮点型:转换为数字的字面样式
    * 数组:转换为"Array"
    * 资源:转换类似"Resource id #1"的字符串,其中的`1`是PHP在运行时分配给该resource的唯一值 
    * 对象:报错 
* 字符串相关函数:详见"字符串函数.md"

## 数组型
* 关键字:`array`
* 存储元素类型:所有类型
* 类型
    * 索引数组:使用十进制数字作为健
    * 关联数组:使用字符串作为键
* 健自动转换
    * 字符仅包含0-9中的数字且不以0开头时,被转换为数字键
    * 浮点值为作索引,被转换为整数
    * 布尔值作为索引,被转换为整数
    * null作为索引,被转换为字符串
    * 对象和数组不能作为键名
* 声明数组
    * 空数组
        ```php 
        $a=[];
        $b=array();
        ```
    * 非空数组:
        ```php 
        $a=array(1,"b"=>2,3);
        $b=[1,2,"c"=>3];
        ```
* 新增元素
    * 使用`[]`新增,将会以最大的索引值自增后的值作为新的索引
        ```php
        $a[]=1;
        ```
    * 使用`[键名]`,将会使用指定的键,若已经存在使用此键的元素则进行覆盖 
        ```php
        $a[1]=5
        ```
* 修改元素
    * 直接使用`[键名]`,对使用此键值的元素进行重新赋值.若不存在使用此键值的元素,则新增
        ```php 
        $a[1]=100;
        ```
* 删除元素
    * 使用`unset()`函数
        ```php 
        unset($a[1]);
        ```
* 访问元素
    * 使用`{}`或`[]`
        ```php 
        echo $a[0];
        echo $a{1};
        ```
* 强制转换为数组:`(关键字)$var`
    * 整型,浮点,字符串,布尔,资源类型:得到一个仅有一个元素的数组,其下标为0,该元素即为此`$var`的值
    * object:结果为一个数组,其单元为该对象的属性.键名将为成员变量名.整数属性不可访问,私有变量前会加上类名作前缀,保护变量前会加上一个 '*' 做前缀,这些前缀的前后都各有一个`NULL`字符,这会导致一些不可预知的行为
    * null:[]
* 运算
    * 联合`+`:`$a+$b`运算符把右边的数组元素附加到左边的数组后面，两个数组中都有的键名，则只保留左边数组中的元素
    * 合并`函数array_merge`:所有数字索引元素全部保留但是数字键值重新索引;关联键值如果有相同的键值,则后一个值覆盖前一个值
    * 相等`==`:`$a==$b`如果$a和$b具有相同的键值对则为TRUE
    * 全等`===`:`$a===$b`如果$a和$b具有相同的键值对并且顺序和类型都相同则为TRUE 
    * 不等`!=`或`<>`:`$a<>$b`如果$a不等于$b则为TRUE
    * 不全等`!==`:如果$a不全等于$b则为TRUE
* 赋值数组:不是引用的元素则行复制,引用的元素则还是进行引用
    ```php 
    $a=5;
    $b=15;
    $c=[
        "a"=>&$a,
        "b"=>$b,
    ];
    $d=$c;
    $d['a']=50;
    $d['b']=60;
    echo $a."\n";
    echo $b."\n";
    ```
    输出:
    ```
    50
    15
    ```

## 对象型
* 关键字:`object`
* 初始化:`new`
    ```php
    class foo
    {
        function do_foo()
        {
            echo "Doing foo."; 
        }
    }
    $bar = new foo();
    $bar->do_foo();
    ```
* 转换为对象:`(关键字)$var`
    * 对象:无变化
    * 其他类型:转换为内置类`stdClass`
        * null:类`stdClass`为空
        * 数组:元素键值对应类`stdClass`中的属性名与值
            * 访问对象中的数字健
                ```php
                $a=["a"=>65,8=>8];
                $c=(object)$a;
                print_r($c->{'8'});
                ```
        * 其他类型:类`stdClass`中含有一个成员变量scalar,存储的值为要转换为对象的值

## 资源型
* 关键字:`resource`
* 说明:特殊类型,通过专门的函数建立与使用

## 回调类型
* 关键字:`callback`,`callable`
* 传递
    * 内置函数,自定义非对象函数,类静态函数:使用字符串(方法名)进行传递.类静态函数的方法名为(类名::函数名)
    * 类函数:使用数组进行传递 
        * 静态方法 
            1. 0=>类名字符串
            1. 1=>方法名
        * 非静态方法
            1. 0=>实例化的类
            1. 1=>方法名
* 使用`call_user_func()`函数
    * 原型:`call_user_func ( callable $callback [, mixed $parameter [, mixed $... ]] ) : mixed`
    * 功能:调用回调函数
    * 返回值:取决于回调函数
    * callback:回调函数的传递 
    * parameter:回调函数的第一个参数.多个参数依次所追加
